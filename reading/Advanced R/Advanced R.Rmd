---
title: "Advanced R"
output: 
  html_document: 
    keep_md: yes
---

### 2.数据结构

#### 2.1 向量(vector)

R语言中的数据类型大致可以分为，

- 一维：向量(vector)，列表(list)
- 二维：矩阵(matrix)，数据框(dataframe)
- n维：数组(array)

向量有三个共同的属性，

- 类型，typeof()
- 长度，元素的个数，length()
- 属性，attributes

向量的元素类型必须相同，列表(list)可以不同

要判断一个对象是否是向量，不能使用is.vector()而要用is.atomic() || is.list()

#### 2.1.1 原子向量(atomic vector)

向量共有六种类型，分别为logical、integer、double、character、complex、raw，integer类型数字后面加L后缀，另外c()函数不起作用，向量永远是平的。缺失值为NA，注意NA也有logical、integer等之分。

#### 2.1.1.1 向量类型测试

- is.logical()
- is.integer()
- is.double()
- is.character()
- is.atomic()
- is.numeric()

#### 2.1.1.2 强制转换

因为向量的元素类型必须一致，所以当类型不一致时就会进行转换，顺序为logical>integer>double>character

#### 2.1.2 列表(list)

```{r}
x <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))
str(x)

```

c()会把元素拆开为独立的个体，list可以保留元素的固有类型，

```{r}
x <- list(list(1, 2), c(3, 4))
y <- c(list(1, 2), c(3, 4))
str(x)
str(y)

```

将列表转换为向量使用unlist(),向量转为列表使用as.list()

#### 2.1.3 作业

1.atomic vector的六种类型？list与atomic的区别？

atomic六种类型为int，double，logic，character，complex，raw。list元素类型可以不同，vector只能同种类型，list可以嵌套，vector不能嵌套。

2.is.vector和is.numeric与is.list和is.character有什么根本的区别？

is.vector测试一个向量是否只有名字属性，要测试一个对象是否为向量用is.atomic(x)||is.list(x)，is.list()测试是否为列表，is.numeric测试一个对象是否是数值型，包括integer和double，is.character测试一个向量是否是字符型。

3.强制转换

```{r}
c(1, F)
c("a", 1)
c(list(1), "a")
c(T, 1L)

```

4.将列表转换成向量为什么要用unlist而不用as.vector?

5.解释下面表示的结果

```{r}
1 == "1"
-1 <= FALSE
"one" < 2

```

6.为什么NA是一个逻辑向量？

#### 2.2 属性

对象可以有任何的属性。属性可以看做一个带有名字的列表，通过attr()和attributes()访问。

```{r}
y <- 1:10
attr(y, "my_attribute") <- "This is a vector"
attr(y, "my_attribute")
str(attributes(y))

```

structure()函数可以返回一个拥有新属性的对象，经常用在面向对象编程方面。

```{r}
structure(1:10, my_attribute = "This is a vector")

```

默认情况下，当修改一个向量时它的大部分属性会随之消失，

```{r}
attributes(y[1])

```

除了三个属性，

- 名字，name()
- 维度，dim()
- 类，class()

#### 2.2.0.1 名字

设置名字有三种方式，

- x <- c(a = 1, b = 2, c = 3).
- x <- 1:3; names(x) <- c("a", "b", "c")
- x <- setNames(1:3, c("a", "b", "c"))

名字不必唯一，但是取对象子集需要一个唯一的名字。

如果一个向量的元素有些没有名字，那么对于这些元素names()将返回空字符，注意不是NULL，如果所有元素都没有名字，那么names()将返回NULL，

```{r}
y <- c(a = 1, 2, 3)
names(y)
z <- c(1, 2, 3)
names(z)

```

去掉一个向量的名字可以使用unname()或者names(x) <- NULL

#### 2.2.1 因子

因子只能取一些预定义好的值(levels)，因子内部存储的实际是整型值(integer)，因子有两个重要的属性，class和levels，

```{r}
x <- factor(c("a", "b", "b", "a"))
x
class(x)
typeof(x)
levels(x)

```

```{r}
# "c"不属于levels
x[2] <- "c"
x
# 拼接factor没有意义
c(factor("a"), factor("b"))

```

使用factor可以更直观的显示，

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))
table(sex_char)
table(sex_factor)
```

如果想以character的方式处理factor，最好通过as.character()显式的转换。

#### 2.2.2 作业

1.为什么comment属性没有打印出来，
```{r}
structure(1:5, comment = "my attribute")

```

一些特殊的属性例如class、comment将会特殊对待，comment不会被print打印

2.当你修改一个因子的levels会怎么样？

```{r}
f1 <- factor(letters)
str(f1)
table(f1)
levels(f1) <- rev(levels(f1))
str(f1)
table(f1)

```

显示顺序会变化，内部的映射关系会变化。

3.下面的代码和f1相同吗？

```{r}
f2 <- rev(factor(letters))
f3 <- factor(letters, levels = rev(letters))

```

f2与f1levels不同，f3与f1的值不同

#### 2.3 矩阵和数组(matrix, array)

数组其实是拥有dim属性的向量，而矩阵是数组的一种特殊形式：二维数组。

length()和names()在多维情况下有更具体的形式，

- length(),对于矩阵有nrow(),ncol()，且length=nrow*ncol，对于数组有dim()
- names(),对于矩阵有rownames()和colnames(),对于数组有dimnames()

注意一点，不是仅有vector是一维的，matrix和array也可以一维，但是它们的输出和处理是不同，这一点尤为注意。

```{r}
str(1:3) # 1d vector
#> int [1:3] 1 2 3
str(matrix(1:3, ncol = 1)) # column vector
#> int [1:3, 1] 1 2 3
str(matrix(1:3, nrow = 1)) # row vector
#> int [1, 1:3] 1 2 3
str(array(1:3, 3)) # "array" vector
#> int [1:3(1d)] 1 2 3

```

不只向量可以添加dim属性，列表也可以添加，然后构成列表矩阵或列表数组，

```{r}
l <- list(1:3, "a", TRUE, 1.0)
dim(l) <- c(2, 2)
l

```

#### 2.3.1 作业

1.dim(向量)返回什么？

NULL

2.如果is.matrix(x)返回TRUE，is.array(x)返回什么？

返回TRUE，is.matrix只要dim属性的length为2就返回TRUE，is.array只要dim属性的length大于0就返回TRUE

3.下面的对象与1:5有什么区别？

```{r}
x1 <- array(1:5, c(1, 1, 5))
x2 <- array(1:5, c(1, 5, 1))
x3 <- array(1:5, c(5, 1, 1))

```


1:5没有dim属性

#### 2.4 数据框(dataframe)

本质上一个数据框是一个列表，这些列表的元素是length相同的向量，所以它具有matrix和list的特点。对于数据框，

- 和矩阵一样，拥有names，rownames，colnames，并且names=colnames，但是对于矩阵names和colnames不同。
- 和列表一样，拥有length，nrow，ncol，且length=ncol，对于矩阵length=ncol*nrow。

#### 2.4.1 创建一个数据框

```{r}
df <- data.frame(x = 1:3, y = c("a", "b", "c"))
str(df)

```

默认情况下，data.frame将character转换为factor，使用stringAsFactors = FALSE参数来禁止这一点。

#### 2.4.2 检测类型和强制转换

数据框是一个S3对象，它本质上是一个list。

```{r}
typeof(df)
#> [1] "list"
class(df)
#> [1] "data.frame"
is.data.frame(df)
#> [1] TRUE

```

可以使用as.data.frame()将向量、列表等转换为数据框，规则为

- 向量将会转为一个只有一列的数据框
- 列表的每一个元素将会转为一列，元素的length必须相同，不同时可以使用I()函数就行修正
- 矩阵将会转为一个相似的数据框

```{r}
# data.frame(x = 1:3, y = list(1:2, 1:3, 1:4))
dfl <- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4)))
str(dfl)

```


#### 2.4.3 拼接数据框

- cbind，当进行列拼接时，行数必须相同
- rbind，当进行行拼接时，列名和列数都必须相同

注意将向量进行cbind不会成为一个数据框而是一个矩阵，这种情况下直接使用data.frame()

#### 2.4.5 作业

1.一个数据框有哪些属性

names=colnames，row.names()，class

2.as.matrix()作用于一个列类型数据框将会如何？

强制转换，参考c()

3.一个数据框可以是0行吗，可以是0列吗？

```{r}
data.frame()

```

### 3.Subsetting

### 3.1.1 向量

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)

```

对于一个向量有五种取子集的方法，

- 正整数

```{r}
x[c(3, 1)]
# 强制转换为整型
x[c(2.1, 2.9)]

```

- 负整数

去除相应位置的值，这点和Python不同，但是正数和负数不能混合使用。

```{r}
x[-c(3, 1)]

```

- 逻辑向量，取TRUE所在位置的值

```{r}
x[c(TRUE, TRUE, FALSE, FALSE)]
x[x > 3]

```

逻辑向量长度小于被subsetting的向量的长度时，逻辑向量将会循环拓宽直到等于subsetting向量的长度，长度大于subsetting的向量的长度时，取值为NA

```{r}
x[c(TRUE, FALSE)]
# Equivalent to
x[c(TRUE, FALSE, TRUE, FALSE)]

```

- 空将返回原来的向量，这在矩阵和数组中非常有用，空将会保留全部的元素

```{r}
x[]

```

- 0返回一个length为0的vector

```{r}
x[0]

```

- 当向量有名字时，可以用字符向量来取子集

```{r}
(y <- setNames(x, letters[1:4]))
y[c("d", "c", "a")]

```

#### 3.1.2 列表

[返回一个list，而[[和$返回元素的类型

#### 3.1.3 矩阵和数组

有三种取子集的方法，

- 多个向量，返回向量
- 单个向量，返回矩阵
- 一个矩阵(仅限integer类型)，每一行对应一个位置，所以用2列的矩阵取一个矩阵的子集，3列的矩阵取一个3d数组的子集，返回值为一个向量
- 当为逻辑矩阵时参考作业第三题

```{r}
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals[c(4, 15)]
select <- matrix(ncol = 2, byrow = TRUE, c(
1, 1,
3, 1,
2, 4
))
vals[select]
str(vals[select])

```

#### 3.1.4 数据框

数据框同时具有列表和矩阵的特性，当用单个向量取子集时，类似列表，当用多个向量取子集时，类似矩阵。

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
# Like a list:
df[c("x", "z")]
# Like a matrix
df[, c("x", "z")]
# 有一个特殊情况，当只取一列时，list方式返回一个dataframe，matrix方式返回一个vector
str(df["x"])
str(df[, "x"])

```

#### 3.1.5 S3类型

包括原始向量(atomic vector)，列表(list)，数组(array)，列表(list)，上面取子集的方法就是针对的S3类型

#### 3.1.6 S4类型

对于S4类型有两个特别的取子集操作符，@(相当于$)，slot()相当于[[。@比$更严谨些，当slot不存在时将返回一个错误。

#### 3.1.7 作业

2.为什么x<- 1:5，x[NA]返回5个缺失值？

因为NA是一个逻辑向量，当长度不及x的length时，将会自动扩展为5，然后返回5个缺失值

3.upper.tri()返回什么？用它来取子集有什么特殊的规则？

```{r}
x <- outer(1:5, 1:5, FUN = "*")
x[upper.tri(x)]

```

一个逻辑矩阵取子集将会取TRUE所在位置的值，并且是列优先，返回一个向量

4.mtcars[1:20]和mtcars[1:20, ]有什么区别？

前者取1到20列，后者取1到20行

6.df[is.na(df)] <- 0是什么意思？

将df中NA值替换为0

#### 3.2 subsetting操作符

```{r}
# If you do supply a vector it indexes recursively
b <- list(a = list(b = list(c = list(d = 1))))
b[[c("a", "b", "c", "d")]]
# Same as
b[["a"]][["b"]][["c"]][["d"]]

```

[,[[,$,对于s3和s4表现不同，

> The key difference is usually how you select between simplifying or preserving behaviours, and what the default is.

#### 3.2.1 Simplifying vs. preserving subsetting

- Simplifying subsets returns the simplest possible data structure that can represent the output, and is useful interactively.
- Preserving subsetting keeps the structure of the output the same as the input, and is generally better for programming because the result will always be the same type.

simplify preserving

- vector和list:x[[1]],x[1]
- factor：x[1:4, drop=T],x[1:4]
- array:x[1, ]或x[, 1],x[1, drop=F]或x[, 1, drop=F]
- dataframe:x[, 1]或x[[1]], x[, 1, drop=F]或x[1]

#### 3.2.2 $

$是一个简化的操作符，可以部分匹配属性名，x$y相当于x[["y", exact= FALSE]]

#### 3.3 subsetting and assignment

```{r}
# Subsetting with nothing can be useful in conjunction with assignment
# return dataframe
mtcars[] <- lapply(mtcars, as.integer)
# return list
mtcars <- lapply(mtcars, as.integer)

```

```{r}
# 使用subseting+assignment+NULL来删除list的元素
x <- list(a = 1, b = 2)
x[["b"]] <- NULL
str(x)
# 添加NULL到list，使用list(NULL)
y <- list(a = 1)
y["b"] <- list(NULL)
str(y)

```

#### 3.4 应用

#### 3.4.1 character subsetting

```{r}
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]

```

#### 3.4.2 integer subsetting

```{r}
grades <- c(1, 2, 2, 3, 1)
info <- data.frame(
grade = 3:1,
desc = c("Excellent", "Good", "Poor"),
fail = c(F, F, T)
)

# 第一种方法Using match
id <- match(grades, info$grade)
info[id, ]
# 第二种方法Using rownames
rownames(info) <- info$grade
info[as.character(grades), ]
```

#### 3.4.7 logical subsetting

mtcars[mtcars$gear == 5, ]

#### 3.4.9 作业

1.如何随机排列一个数据框的列？

mtcars[, sample(ncol(mtcars))]

2.如何随机选择m行

mtcars[sample(nrows(mtcars), m), ]

3.如何将数据框的列按字母顺序排列？

mtcars[, order(colnames(mtcars))]

### 6.函数

#### 6.1 函数组成

有三部分组成，

- body()：函数体
- formals():参数
- environment():函数变量所在的位置

```{r}
f <- function(x) x^2
f
formals(f)
body(f)
environment(f)

```

和R语言的其他对象一样，函数也可以拥有任意数量的attributes()

#### 6.1.1 原始函数(primitive function)

原始函数是一个例外，它没有上述三个组成部分，它通过.Primitive()直接调用c函数，它只存在base包中

#### 6.1.2 作业

1.如何检测一个对象是函数？原始函数呢？

is.function()
is.primitive()

2.下面的代码返回base包里的所有函数，

```{r}
objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs)

```

- 哪个函数参数最多？

```{r}
formals_length <- unlist(lapply(funs, function(x)length(formals(x))))
which.max(formals_length)

```

- 有多少函数没有参数？这些函数有什么特点？

```{r}
sum(formals_length == 0)

```

它们有的是原始函数，有的是无参数函数

- 怎样修改代码来查找所有的原始函数？

```{r}
objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.primitive, objs)
length(funs)

```

3.函数的三个组成部分？

body,formals,environment

4.什么情况下不会打印函数的环境？

原始函数






























